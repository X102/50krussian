<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T·ª´ ƒêi·ªÉn T·∫ßn Su·∫•t Ti·∫øng Nga (Full Features)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        :root { --primary-color: #0d6efd; --bg-color: #f0f2f5; }
        body { background-color: var(--bg-color); font-family: 'Segoe UI', sans-serif; }

        /* --- THANH C√îNG C·ª§ --- */
        .sticky-header {
            position: sticky; top: 0; z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid #ddd;
            padding: 10px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        /* --- B·ªê C·ª§C MASONRY --- */
        .masonry-container { column-count: 1; column-gap: 15px; }
        @media (min-width: 576px) { .masonry-container { column-count: 2; } }
        @media (min-width: 992px) { .masonry-container { column-count: 3; } }
        @media (min-width: 1200px) { .masonry-container { column-count: 4; } }

        /* --- TH·∫∫ T·ª™ V·ª∞NG --- */
        .word-card {
            break-inside: avoid;
            background: white; border-radius: 10px; margin-bottom: 15px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.02);
            position: relative; overflow: hidden; transition: transform 0.2s;
        }
        .word-card:hover { border-color: #b0c4de; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        .word-card.no-meaning { background: #fafafa; border-style: dashed; }

        .lemma { font-size: 1.4rem; font-weight: 700; color: var(--primary-color); cursor: pointer; }
        .lemma:hover { text-decoration: underline; }
        
        /* --- N·ªòI DUNG & N√öT XEM TH√äM --- */
        .meaning-wrapper { position: relative; font-size: 0.95rem; color: #333; line-height: 1.5; }
        .meaning-collapsed {
            max-height: 120px; overflow: hidden;
            mask-image: linear-gradient(180deg, #000 60%, transparent);
            -webkit-mask-image: linear-gradient(180deg, #000 60%, transparent);
        }
        .toggle-btn {
            display: none; width: 100%; background: #f8f9fa; border: none;
            border-top: 1px solid #eee; padding: 5px 0;
            color: var(--primary-color); font-size: 0.85rem; font-weight: 600;
            cursor: pointer; transition: background 0.2s;
        }
        .toggle-btn:hover { background: #e9ecef; }

        /* Style Format T·ª´ ƒëi·ªÉn */
        .stress { color: #d63384; font-weight: bold; }
        .example { display: block; margin-top: 4px; color: #666; font-style: italic; font-size: 0.9em; padding-left: 10px; border-left: 2px solid #eee; }
        .rank-badge { float: right; font-size: 0.75rem; background: #eee; padding: 2px 6px; border-radius: 4px; color: #555; }
        .word-card .btn-light { border: 1px solid #eee; transition: all 0.2s; }
        .word-card .btn-light:hover { background-color: #e9ecef; border-color: #cbd3da; transform: translateY(-1px); }

        /* --- N√öT ƒêI·ªÄU H∆Ø·ªöNG (SCROLL BUTTONS) --- */
        .scroll-btn {
            position: fixed; right: 30px; width: 45px; height: 45px;
            border-radius: 50%; border: none; font-size: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: none; z-index: 999; cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }
        .scroll-btn:hover { transform: scale(1.1); }
        
        #btnScrollTop { bottom: 85px; background: #343a40; color: white; } /* N√∫t l√™n n·∫±m tr√™n */
        #btnScrollBottom { bottom: 30px; background: var(--primary-color); color: white; } /* N√∫t xu·ªëng n·∫±m d∆∞·ªõi */

        #selectionSpeakBtn::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #212529 transparent transparent transparent; /* M√†u ƒëen tr√πng m√†u n√∫t */
        }

        /* Hi·ªáu ·ª©ng th·∫ª ƒëang ƒë∆∞·ª£c ƒë·ªçc (Playlist) */
        .word-card.reading-active {
            border: 2px solid #0d6efd;
            background-color: #e7f1ff !important;
            box-shadow: 0 0 15px rgba(13, 110, 253, 0.3);
            transform: scale(1.02);
            z-index: 10;
        }

        /* N√∫t ƒë·ªçc to√†n b·ªô tr√™n Header */
        #btnPlayAll {
            min-width: 45px;
            transition: all 0.3s;
        }
        .playing-state {
            background-color: #dc3545 !important; /* M√†u ƒë·ªè khi ƒëang ch·∫°y ƒë·ªÉ b·∫•m d·ª´ng */
            border-color: #dc3545 !important;
            color: white !important;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

    </style>
</head>
<body>

<div class="sticky-header">
    <div class="container-fluid px-4">
        <div class="row align-items-center g-2">
            <div class="col-12 col-md-3">
                <div class="fw-bold text-primary fs-5">50,000 T·ª´ v·ª±ng ti·∫øng Nga</div>
                <small class="text-muted" id="statusDisplay">ƒêang t·∫£i...</small>
            </div>
            <div class="col-6 col-md-6">
                <input type="text" id="searchInput" class="form-control" placeholder="T√¨m ki·∫øm t·ª´ (nguy√™n th·ªÉ) ho·∫∑c nghƒ©a...">
            </div>
            <div class="col-4 col-md-3 d-flex">
            <button id="btnPlayAll" class="btn btn-outline-success me-2" onclick="togglePlayAll()" title="ƒê·ªçc to√†n b·ªô trang">
                ‚ñ∂
            </button>
            
            <input type="number" id="rankInput" class="form-control me-2" placeholder="STT" min="1">
            <button class="btn btn-primary" onclick="jumpToRank()">Go</button>
            </div>
        </div>
    </div>
</div>

<div class="container-fluid px-4 py-3">
    <div id="wordList" class="masonry-container"></div>
    
    <div class="text-center py-4">
        <div id="loadingSpinner" class="spinner-border text-primary" role="status"></div>
        <button id="loadMoreBtn" class="btn btn-outline-primary px-5 rounded-pill shadow-sm" style="display:none;">Xem th√™m</button>
    </div>
</div>
<footer class="bg-white border-top mt-5 pt-5 pb-5">
    <div class="container">
        <div class="row">
            <div class="col-md-5 mb-4">
                <h5 class="fw-bold text-primary">V·ªÅ b·ªô t·ª´ ƒëi·ªÉn n√†y</h5>
                <p class="text-muted">
                    Trang web n√†y ƒë∆∞·ª£c x√¢y d·ª±ng ƒë·ªÉ gi√∫p ng∆∞·ªùi Vi·ªát Nam tra c·ª©u, h·ªçc 50.000 t·ª´ v·ª±ng ti·∫øng Nga ph·ªï bi·∫øn nh·∫•t. 
                    D·ªØ li·ªáu ƒë∆∞·ª£c s·∫Øp x·∫øp t·ª´ xu·∫•t hi·ªán nhi·ªÅu nh·∫•t ƒë·∫øn √≠t h∆°n, t√≠ch h·ª£p nghƒ©a ti·∫øng Vi·ªát v√† c√°c c√¥ng c·ª• tra c·ª©u m·ªü r·ªông.
                </p>
            </div>

            <div class="col-md-4 mb-4">
                <h5 class="fw-bold">üìä Ngu·ªìn d·ªØ li·ªáu</h5>
                <ul class="list-unstyled text-muted">
                    <li class="mb-2">
                        üîπ <strong>T·ª´ ƒëi·ªÉn t·∫ßn su·∫•t t·ª´:</strong> 
                        <a href="https://github.com/Digital-Pushkin-Lab/Russian_frequency_lists" target="_blank" class="text-decoration-none"> Digital Pushkin Lab</a>
                    </li>
                    <li class="mb-2">
                        üîπ <strong>Nghƒ©a ti·∫øng Vi·ªát:</strong> 
                        <a href="https://huggingface.co/datasets/lopmaybay/trungvietstardict" target="_blank" class="text-decoration-none">T·ª´ ƒëi·ªÉn Nga Vi·ªát StarDict</a>
                    </li>
                    <li>
                        üîπ <strong>Tra c·ª©u ngo√†i:</strong> Google Translate, Yandex, Google Images, Vtudien, Youglish, Wikitionary.
                    </li>
                </ul>
            </div>

            <div class="col-md-3 mb-4">
                <h5 class="fw-bold">üë®‚Äçüíª Li√™n h·ªá t√°c gi·∫£</h5>
                <p class="text-muted">
                    Ph√°t tri·ªÉn b·ªüi: <strong>Ph·∫°m ƒêƒÉng Hi·ªÉn</strong><br>
                    <small>lopmaybay@gmail.com</small>
                </p>
                <div>
                    <a href="https://t.me/lopmaybay" class="btn btn-outline-secondary btn-sm me-1">Telegram</a>
                    <a href="https://www.facebook.com/lopmaybay" class="btn btn-outline-primary btn-sm">Facebook</a>
                </div>
            </div>
        </div>

        <div class="text-center text-muted border-top pt-3 mt-3 small">
            &copy; 2025 Russian Frequency Dictionary. All rights reserved.
        </div>
    </div>
</footer>
<button onclick="scrollToTopFn()" id="btnScrollTop" class="scroll-btn" title="L√™n ƒë·∫ßu trang">‚¨Ü</button>
<button onclick="scrollToTopFn()" id="btnScrollTop" class="scroll-btn" title="L√™n ƒë·∫ßu trang">‚¨Ü</button>
<button onclick="scrollToBottomFn()" id="btnScrollBottom" class="scroll-btn" title="Xu·ªëng cu·ªëi trang">‚¨á</button>
<button id="selectionSpeakBtn" class="btn btn-dark btn-sm shadow rounded-pill" 
        style="display: none; position: fixed; z-index: 9999; padding: 5px 15px; font-weight: bold; top: 0; left: 0;">
    üîä Nghe
</button>
<button onclick="openSettings()" class="btn btn-light shadow rounded-circle border" 
        style="position: fixed; bottom: 30px; left: 30px; width: 50px; height: 50px; z-index: 1001;" 
        title="C√†i ƒë·∫∑t gi·ªçng ƒë·ªçc">
    ‚öôÔ∏è
</button>

<div class="modal fade" id="settingsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title fw-bold">üéß C√†i ƒë·∫∑t Gi·ªçng ƒë·ªçc</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-4">
                    <label class="form-label fw-bold">üá∑üá∫ Gi·ªçng Ti·∫øng Nga</label>
                    <select id="ruVoiceSelect" class="form-select" onchange="saveVoiceSettings()">
                        <option value="">-- M·∫∑c ƒë·ªãnh --</option>
                    </select>
                </div>

                <div class="mb-4">
                    <label class="form-label fw-bold">üáªüá≥ Gi·ªçng Ti·∫øng Vi·ªát</label>
                    <select id="viVoiceSelect" class="form-select" onchange="saveVoiceSettings()">
                        <option value="">-- M·∫∑c ƒë·ªãnh --</option>
                    </select>
                </div>
                
                <div class="mb-3">
                    <label class="form-label fw-bold">T·ªëc ƒë·ªô ƒë·ªçc: <span id="rateValue">1.0</span>x</label>
                    <input type="range" class="form-range" min="0.5" max="1.5" step="0.1" id="rateRange" value="1.0" oninput="saveVoiceSettings()">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary w-100" data-bs-dismiss="modal">ƒê√£ xong</button>
            </div>
        </div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
    const DATA_URL = 'russian_learning_data(5).json'; 
    const BATCH_SIZE = 50;

    let fullDataset = [];
    let currentData = [];
    let renderedCount = 0;


    async function init() {
        try {
            const res = await fetch(DATA_URL);
            fullDataset = await res.json();
            currentData = fullDataset;
            
            document.getElementById('loadingSpinner').style.display = 'none';
            document.getElementById('statusDisplay').innerText = `T·ªïng: ${fullDataset.length.toLocaleString()} t·ª´`;
            
            renderNextBatch();
        } catch (e) {
            alert("L·ªói t·∫£i data: " + e.message);
        }
    }

            // --- QU·∫¢N L√ù GI·ªåNG ƒê·ªåC (VOICE SETTINGS) ---
    let availableVoices = [];
    let selectedRuVoiceURI = localStorage.getItem('ruVoiceURI') || "";
    let selectedViVoiceURI = localStorage.getItem('viVoiceURI') || "";
    let speechRate = parseFloat(localStorage.getItem('speechRate')) || 1.0;

    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã thanh tr∆∞·ª£t t·ªëc ƒë·ªô
    document.getElementById('rateRange').value = speechRate;
    document.getElementById('rateValue').innerText = speechRate;

    // 1. H√†m l·∫•y danh s√°ch gi·ªçng t·ª´ tr√¨nh duy·ªát
    function populateVoiceList() {
        availableVoices = window.speechSynthesis.getVoices();
        
        const ruSelect = document.getElementById('ruVoiceSelect');
        const viSelect = document.getElementById('viVoiceSelect');

        // X√≥a danh s√°ch c≈© (tr·ª´ option ƒë·∫ßu ti√™n)
        ruSelect.innerHTML = '<option value="">-- M·∫∑c ƒë·ªãnh (H·ªá th·ªëng) --</option>';
        viSelect.innerHTML = '<option value="">-- M·∫∑c ƒë·ªãnh (H·ªá th·ªëng) --</option>';

        availableVoices.forEach((voice) => {
            const option = document.createElement('option');
            // Hi·ªÉn th·ªã t√™n gi·ªçng + (Ng√¥n ng·ªØ)
            option.textContent = `${voice.name} (${voice.lang})`;
            option.value = voice.voiceURI; // D√πng URI ƒë·ªÉ ƒë·ªãnh danh ch√≠nh x√°c

            // Ph√¢n lo·∫°i v√†o dropdown t∆∞∆°ng ·ª©ng
            if (voice.lang.includes('ru')) {
                ruSelect.appendChild(option);
                if (voice.voiceURI === selectedRuVoiceURI) option.selected = true;
            } 
            else if (voice.lang.includes('vi')) {
                viSelect.appendChild(option);
                if (voice.voiceURI === selectedViVoiceURI) option.selected = true;
            }
        });
    }

    // 2. S·ª± ki·ªán ch·ªù tr√¨nh duy·ªát load gi·ªçng (Chrome c·∫ßn c√°i n√†y)
    if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = populateVoiceList;
    }
    // G·ªçi ngay l·∫≠p t·ª©c ph√≤ng khi gi·ªçng ƒë√£ load xong r·ªìi
    populateVoiceList();

    // 3. L∆∞u c√†i ƒë·∫∑t khi ng∆∞·ªùi d√πng thay ƒë·ªïi
    window.saveVoiceSettings = function() {
        const ruSelect = document.getElementById('ruVoiceSelect');
        const viSelect = document.getElementById('viVoiceSelect');
        const rateRange = document.getElementById('rateRange');

        selectedRuVoiceURI = ruSelect.value;
        selectedViVoiceURI = viSelect.value;
        speechRate = parseFloat(rateRange.value);

        // C·∫≠p nh·∫≠t UI text
        document.getElementById('rateValue').innerText = speechRate;

        // L∆∞u v√†o b·ªô nh·ªõ tr√¨nh duy·ªát
        localStorage.setItem('ruVoiceURI', selectedRuVoiceURI);
        localStorage.setItem('viVoiceURI', selectedViVoiceURI);
        localStorage.setItem('speechRate', speechRate);
        
        // Test th·ª≠ gi·ªçng ngay khi ch·ªçn (Optional)
        // window.speechSynthesis.cancel();
    }

    // 4. M·ªü modal c√†i ƒë·∫∑t
    window.openSettings = function() {
        // C·∫ßn Bootstrap JS ƒë·ªÉ m·ªü modal
        const myModal = new bootstrap.Modal(document.getElementById('settingsModal'));
        populateVoiceList(); // Refresh l·∫°i list cho ch·∫Øc
        myModal.show();
    }

    function cleanRawMeaning(html) {
        if (!html) return "";
        let clean = html;
        clean = clean.replace(/\[p\](.*?)\[\/p\]/g, '<span class="text-secondary fst-italic small"> ($1) </span>');
        clean = clean.replace(/\[\/?m\d?\]/g, '');
        clean = clean.replace(/\\/g, '');
        clean = clean.replace(/~/g, '<b class="text-primary">~</b>');
        clean = clean.replace(/^(<br>)+|(<br>)+$/g, '');
        return clean;
    }

    function renderNextBatch() {
        const container = document.getElementById('wordList');
        const batch = currentData.slice(renderedCount, renderedCount + BATCH_SIZE);
        
        if (batch.length === 0) {
            document.getElementById('loadMoreBtn').style.display = 'none';
            if(renderedCount === 0) container.innerHTML = `<div class="lemma mb-1" onclick="speak('${searchInput.value}')">${searchInput.value} üîä</div>
            <div class="lemma mb-1" onclick="speak('${searchInput.value}', '${searchInput.value}')">${searchInput.value} <span style="font-size:0.8em">üîä</span></div>            
            <a href="https://translate.google.com/?sl=ru&tl=vi&text=${searchInput.value}" target="_blank"> Tra Google d·ªãch |</a>
                        <a href="https://vtudien.com/nga-viet/dictionary/nghia-cua-tu-${searchInput.value}" target="_blank"> Vtudien |<a/>
                        <a href="https://youglish.com/pronounce/${searchInput.value}/russian" target="_blank"> Youglish |<a/>
                        <a href="https://ru.wiktionary.org/wiki/${searchInput.value}" target="_blank"> Wikitionary |<a/>
                        <a href="https://yandex.ru/search/?text=${searchInput.value}" target="_blank"> Yandex |<a/>
                        <a href="https://www.google.com/search?q=t·ª´+v·ª±ng+ti·∫øng+nga+${searchInput.value}" target="_blank"> Google |<a/> 
                        <a href="https://www.google.com/search?tbm=isch&q=${searchInput.value}" target="_blank"> Google Images |<a/>
                        <a href="https://tatoeba.org/vi/sentences/search?from=rus&query=${searchInput.value}&to=vie" target="_blank"> Tatoeba <\a>    <br\>    
                        <p class="text-center w-100">Kh√¥ng t√¨m th·∫•y.</p> <\div>`;
            return;
        }

        let html = '';
        batch.forEach((item, index) => {
            const realRank = fullDataset.indexOf(item) + 1;
            const uniqueId = `word-${renderedCount + index}`;
            // ID duy nh·∫•t ƒë∆∞·ª£c t·∫°o ra ·ªü ƒë√¢y
            let hasMeaning = !!item.meaning;
            let rawContent = item.meaning ? cleanRawMeaning(item.meaning) : '';
            let meaningHtml = rawContent || `<div class="text-muted small mt-2">Ch∆∞a c√≥ d·ªØ li·ªáu nghƒ©a. H√£y t·ª± tra th√™m!</div>`;

            let isLongContent = hasMeaning && item.meaning.length > 250; 
            let collapseClass = isLongContent ? 'meaning-collapsed' : '';
            let btnDisplay = isLongContent ? 'block' : 'none';

            // T·∫°o link t√¨m ki·∫øm
            const yandexUrl = `https://yandex.ru/search/?text=${encodeURIComponent(item.lemma)}`;
            const googleUrl = `https://www.google.com/search?q=t·ª´+v·ª±ng+ti·∫øng+nga+${encodeURIComponent(item.lemma)}`;
            const googleImgUrl = `https://www.google.com/search?tbm=isch&q=${encodeURIComponent(item.lemma)}`;

            html += `
                <div id="${uniqueId}" class="word-card ${hasMeaning?'':'no-meaning'}">
                    <div class="p-3">
                        <span class="rank-badge">#${realRank}</span>
                        <div class="lemma mb-1" onclick="speak('${item.lemma}', '${item.lemma}', '${item.lemma}')">
                            ${item.lemma} <span style="font-size:0.8em">üîä</span>
                        </div>
                        <div id="content-${uniqueId}" class="meaning-wrapper ${collapseClass} mb-3">
                            ${meaningHtml}
                        </div>

                        <div class="d-flex gap-2 pt-2 border-top">
                            <button onclick="readSingleCard('word-${renderedCount + index}')" class="btn btn-sm btn-info text-white fw-bold" title="ƒê·ªçc to√†n b·ªô th·∫ª n√†y">üìñ</button>
                            <a href="${yandexUrl}" target="_blank" class="btn btn-sm btn-light flex-fill text-danger fw-bold">Yandex</a>
                            <a href="${googleUrl}" target="_blank" class="btn btn-sm btn-light flex-fill text-primary fw-bold">Google</a>
                            <a href="${googleImgUrl}" target="_blank" class="btn btn-sm btn-light text-secondary">üñºÔ∏è</a>
                            
                        </div>
                        <a href="https://translate.google.com/?sl=ru&tl=vi&text=${item.lemma}" target="_blank"> Google Translate |</a>
                        <a href="https://vtudien.com/nga-viet/dictionary/nghia-cua-tu-${item.lemma}" target="_blank"> Vtudien |<a/>
                        <a href="https://youglish.com/pronounce/${item.lemma}/russian" target="_blank"> Youglish |<a/>
                        <a href="https://ru.wiktionary.org/wiki/${item.lemma}" target="_blank"> Wikitionary |<a/>
                        <a href="https://tatoeba.org/vi/sentences/search?from=rus&query=${item.lemma}&to=vie" target="_blank"> Tatoeba <\a>  
                    </div>
                    <button id="btn-${uniqueId}" class="toggle-btn" style="display:${btnDisplay}" 
                            onclick="toggleCard('${uniqueId}')">
                        üîΩ Xem chi ti·∫øt
                    </button>
                </div>
            `;
        });

        container.insertAdjacentHTML('beforeend', html);
        renderedCount += batch.length;

        const loadMoreBtn = document.getElementById('loadMoreBtn');
        loadMoreBtn.style.display = (renderedCount >= currentData.length) ? 'none' : 'inline-block';
        loadMoreBtn.innerText = `T·∫£i th√™m (${renderedCount}/${currentData.length})`;
    }

    window.toggleCard = function(id) {
        const content = document.getElementById(`content-${id}`);
        const btn = document.getElementById(`btn-${id}`);
        if (content.classList.contains('meaning-collapsed')) {
            content.classList.remove('meaning-collapsed');
            btn.innerHTML = 'üîº Thu g·ªçn';
            btn.style.background = '#e9ecef';
        } else {
            content.classList.add('meaning-collapsed');
            btn.innerHTML = 'üîΩ Xem chi ti·∫øt';
            btn.style.background = '#f8f9fa';
            content.scrollIntoView({behavior: "smooth", block: "center"});
        }
    };

    const searchInput = document.getElementById('searchInput');
    let timeout = null;
    searchInput.addEventListener('input', (e) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            const k = e.target.value.toLowerCase().trim();
            document.getElementById('wordList').innerHTML = '';
            renderedCount = 0;
            if(!k) currentData = fullDataset;
            else currentData = fullDataset.filter(i => 
                (i.lemma && i.lemma.toLowerCase().includes(k)) || 
                (i.meaning && i.meaning.toLowerCase().includes(k))
            );
            renderNextBatch();
        }, 300);
    });

    document.getElementById('loadMoreBtn').addEventListener('click', renderNextBatch);

    window.jumpToRank = function() {
        const r = parseInt(document.getElementById('rankInput').value);
        if(!r || r < 1) return;
        document.getElementById('wordList').innerHTML = '';
        currentData = fullDataset;
        renderedCount = Math.min(r - 1, fullDataset.length - 1);
        renderNextBatch();
        window.scrollTo(0,0);
        searchInput.value = '';
    }

    // --- X·ª¨ L√ù ƒê·ªåC ƒêA NG√îN NG·ªÆ (MIXED LANGUAGE) ---

 

    // --- X·ª¨ L√ù SCROLL N√öT ƒêI·ªÄU H∆Ø·ªöNG ---
    // H√†m cu·ªôn l√™n ƒë·∫ßu
    window.scrollToTopFn = function() {
        window.scrollTo({top: 0, behavior: 'smooth'});
    }
    // H√†m cu·ªôn xu·ªëng cu·ªëi
    window.scrollToBottomFn = function() {
        window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'});
    }
    // Logic ·∫©n hi·ªán n√∫t
    window.onscroll = () => {
        const scrollY = window.scrollY;
        const windowHeight = window.innerHeight;
        const docHeight = document.body.scrollHeight;

        const btnTop = document.getElementById('btnScrollTop');
        const btnBottom = document.getElementById('btnScrollBottom');

        // Hi·ªán n√∫t L√™n n·∫øu cu·ªôn xu·ªëng qu√° 300px
        btnTop.style.display = scrollY > 300 ? 'block' : 'none';

        // Hi·ªán n√∫t Xu·ªëng n·∫øu ch∆∞a ch·∫°m ƒë√°y
        // (Tr·ª´ ƒëi 100px ƒë·ªÉ c√≥ ƒë·ªô tr·ªÖ h·ª£p l√Ω)
        if (windowHeight + scrollY < docHeight - 100) {
            btnBottom.style.display = 'block';
        } else {
            btnBottom.style.display = 'none';
        }
    }

// --- QU·∫¢N L√ù TR·∫†NG TH√ÅI ƒê·ªåC (GLOBAL STATE) ---
let isPlayingAll = false;
let currentCardIndex = -1;
let speechQueue = []; // H√†ng ƒë·ª£i c√°c ƒëo·∫°n c·∫ßn ƒë·ªçc

// Bi·∫øn to√†n c·ª•c ƒë·ªÉ gi·ªØ utterance (Fix l·ªói Chrome b·ªã ng·∫Øt gi·ªØa ch·ª´ng)
window.currentUtterance = null;

function speakSegments(segments, index = 0, onComplete = null) {
    // Ki·ªÉm tra c·ªù d·ª´ng
    if (!isPlayingAll && onComplete) return;

    if (index >= segments.length) {
        window.currentUtterance = null; // Gi·∫£i ph√≥ng b·ªô nh·ªõ
        if (onComplete) onComplete();
        return;
    }

    const segment = segments[index];
    if (!segment.text || segment.text.trim().length === 0) {
        speakSegments(segments, index + 1, onComplete);
        return;
    }

    const u = new SpeechSynthesisUtterance(segment.text);
    u.lang = segment.lang;
    
    // √Åp d·ª•ng gi·ªçng ƒë·ªçc ƒë√£ ch·ªçn (nh∆∞ code tr∆∞·ªõc)
    let targetVoice = null;
    if (u.lang === 'ru-RU' && selectedRuVoiceURI) {
        targetVoice = availableVoices.find(v => v.voiceURI === selectedRuVoiceURI);
    } else if (u.lang === 'vi-VN' && selectedViVoiceURI) {
        targetVoice = availableVoices.find(v => v.voiceURI === selectedViVoiceURI);
    }
    if (targetVoice) u.voice = targetVoice;

    u.rate = (u.lang === 'vi-VN') ? speechRate * 0.9 : speechRate;

    // --- QUAN TR·ªåNG: G√ÅN V√ÄO BI·∫æN TO√ÄN C·ª§C ---
    window.currentUtterance = u; 

    u.onend = () => {
        // ƒê·ªá quy ƒëo·∫°n ti·∫øp theo
        speakSegments(segments, index + 1, onComplete);
    };
    
    u.onerror = (e) => { 
        // N·∫øu l·ªói 'interrupted' m√† do h·ªá th·ªëng t·ª± ng·∫Øt ƒë·ªÉ chuy·ªÉn c√¢u -> c·ª© ƒëi ti·∫øp
        // N·∫øu l·ªói do ng∆∞·ªùi d√πng b·∫•m Stop -> h√†m ki·ªÉm tra !isPlayingAll ·ªü ƒë·∫ßu s·∫Ω ch·∫∑n l·∫°i
        console.warn("L·ªói TTS (b·ªè qua v√† ƒë·ªçc ti·∫øp):", e.error);
        speakSegments(segments, index + 1, onComplete); 
    };

    window.speechSynthesis.speak(u);
}

window.speak = function(text, lemma = "", stem = "", onComplete = null) {
    window.speechSynthesis.cancel();
    
    const cleanedText = cleanTextForSpeech(text, lemma, stem);
    
    // LOG ƒê·ªÇ DEBUG
    console.log("Input:", text.substring(0, 50) + "...");
    console.log("Cleaned:", cleanedText);

    // B·∫¢O V·ªÜ: N·∫øu sau khi clean m√† kh√¥ng c√≤n g√¨ -> Next lu√¥n
    if (cleanedText.length === 0) {
        console.warn("VƒÉn b·∫£n r·ªóng, b·ªè qua.");
        if (onComplete) onComplete();
        return;
    }

    const segments = parseMixedText(cleanedText);
    
    // B·∫¢O V·ªÜ: N·∫øu parse ra m·∫£ng r·ªóng
    if (segments.length === 0) {
        if (onComplete) onComplete();
        return;
    }

    speakSegments(segments, 0, onComplete);
}

window.readSingleCard = function(cardId) {
    stopPlayAll();
    
    const card = document.getElementById(cardId);
    if (!card) {
        console.error("Kh√¥ng t√¨m th·∫•y th·∫ª c√≥ ID:", cardId); // Log l·ªói n·∫øu qu√™n g√°n ID
        return;
    }

    // L·∫•y d·ªØ li·ªáu s·∫°ch b·∫±ng h√†m ti·ªán √≠ch ƒë√£ vi·∫øt ·ªü b∆∞·ªõc tr∆∞·ªõc
    const data = getDataFromCard(card);

    console.log("ƒêang ƒë·ªçc th·∫ª:", cardId);
    console.log("N·ªôi dung:", data.fullText);

    isPlayingAll = true; 
    speak(data.fullText, data.lemma, data.stem, () => { isPlayingAll = false; });
}

// ƒê·ªçc Playlist (ƒê·ªá quy)

function playNextCardRecursive() {
    if (!isPlayingAll) return;

    const allCards = document.querySelectorAll('.word-card');
    
    if (currentCardIndex >= allCards.length) {
        // ... (Gi·ªØ nguy√™n logic t·∫£i th√™m trang) ...
        const loadMoreBtn = document.getElementById('loadMoreBtn');
        if (loadMoreBtn && loadMoreBtn.style.display !== 'none') {
            loadMoreBtn.click();
            setTimeout(() => playNextCardRecursive(), 1500); // TƒÉng th·ªùi gian ch·ªù l√™n 1.5s cho ch·∫Øc
            return;
        } else {
            stopPlayAll();
            alert("ƒê√£ ƒë·ªçc h·∫øt!");
            return;
        }
    }

    const card = allCards[currentCardIndex];
    
    // Highlight & Scroll
    document.querySelectorAll('.reading-active').forEach(el => el.classList.remove('reading-active'));
    card.classList.add('reading-active');
    card.scrollIntoView({behavior: "smooth", block: "center"});

    // LOGIC M·ªöI: L·∫•y fullText
    const data = getDataFromCard(card);
    
    // ƒê·ªçc
    speak(data.fullText, data.lemma, data.stem, function() {
        currentCardIndex++;
        // Th√™m delay nh·ªè 0.5s gi·ªØa c√°c th·∫ª cho t·ª± nhi√™n
        if (isPlayingAll) {
            setTimeout(() => playNextCardRecursive(), 500); 
        }
    });
}

// 3. H√ÄM ƒê·ªåC TO√ÄN B·ªò TRANG (PLAYLIST)
window.togglePlayAll = function() {
    const btn = document.getElementById('btnPlayAll');
    
    if (isPlayingAll) {
        stopPlayAll();
    } else {
        startPlayAll();
    }
}

/////////////////////////
function startPlayAll() {
    isPlayingAll = true;
    const btn = document.getElementById('btnPlayAll');
    btn.innerHTML = "‚èπ"; // Bi·ªÉu t∆∞·ª£ng Stop
    btn.classList.add('playing-state');
    
    // B·∫Øt ƒë·∫ßu t·ª´ th·∫ª ƒë·∫ßu ti√™n ho·∫∑c th·∫ª ƒëang d·ªü
    const allCards = document.querySelectorAll('.word-card');
    if (allCards.length === 0) return;

    // Reset index n·∫øu ch∆∞a b·∫Øt ƒë·∫ßu
    if (currentCardIndex < 0) currentCardIndex = 0;

    playNextCardRecursive();
}

function stopPlayAll() {
    isPlayingAll = false;
    window.speechSynthesis.cancel();
    
    const btn = document.getElementById('btnPlayAll');
    btn.innerHTML = "‚ñ∂";
    btn.classList.remove('playing-state');
    
    // X√≥a highlight c≈©
    document.querySelectorAll('.reading-active').forEach(el => el.classList.remove('reading-active'));
}

function cleanTextForSpeech(text, lemma = "", stem = "") {
    if (!text) return "";
    let clean = text;

    // 1. BI·∫æN ƒê·ªîI C·∫§U TR√öC TH√ÄNH C√ÇU NG·∫ÆN
    // Thay th·∫ø xu·ªëng d√≤ng v√† c√°c icon b·∫±ng d·∫•u ch·∫•m ƒë·ªÉ ng·∫Øt c√¢u
    clean = clean.replace(/[\r\n]+/g, ". "); 
    clean = clean.replace(/[üîäüîπüëâ‚Ä¢|‚ñ∫]/g, ". "); // Bi·∫øn icon th√†nh d·∫•u ch·∫•m

    // 2. X·ª≠ l√Ω d·∫•u ng√£ ~ (Logic c≈©)
    if (lemma) {
        clean = clean.replace(/~/g, function(match, offset, fullString) {
            const nextChar = fullString[offset + 1];
            const isSuffix = nextChar && /[–∞-—è–ê-–Ø—ë–Å]/.test(nextChar);
            return (isSuffix && stem) ? stem : lemma;
        });
    }

    // 3. X√≥a c√°c th·∫ª meta ng·∫Øn
    clean = clean.replace(/\([–∞-—è–ê-–Ø—ë–Å\s.,]{1,15}\)/g, " ");

    // 4. D·ªçn d·∫πp d·∫•u ch·∫•m th·ª´a (Quan tr·ªçng)
    // V√≠ d·ª•: ".. . ." -> "."
    clean = clean.replace(/\s*[.;:]\s*/g, ". "); 
    clean = clean.replace(/\.\s*\./g, "."); 
    clean = clean.replace(/\s+/g, " ").trim();
    // clean = clean.replace(/\d\[a-z]/, " ").trim();
    
    return clean;
}

// H√†m chia nh·ªè vƒÉn b·∫£n d√†i th√†nh c√°c c√¢u ng·∫Øn h∆°n
function splitSmart(text, lang) {
    // T√°ch theo d·∫•u ch·∫•m, ch·∫•m ph·∫©y, hai ch·∫•m, ch·∫•m than, ch·∫•m h·ªèi
    // Regex n√†y gi·ªØ l·∫°i d·∫•u c√¢u ƒë·ªÉ ƒë·ªçc cho t·ª± nhi√™n
    const rawSegments = text.split(/([.;:?!])/); 
    const results = [];
    
    let buffer = "";
    
    for (let part of rawSegments) {
        buffer += part;
        // N·∫øu buffer ƒë√£ ƒë·ªß d√†i (tr√™n 20 k√Ω t·ª±) ho·∫∑c g·∫∑p d·∫•u c√¢u k·∫øt th√∫c -> ƒê·∫©y v√†o m·∫£ng
        // Gi·ªõi h·∫°n 150 k√Ω t·ª± ƒë·ªÉ an to√†n tuy·ªát ƒë·ªëi
        if (buffer.length > 20 && /[.;:?!]/.test(part) || buffer.length > 150) {
            if (buffer.trim()) results.push({text: buffer.trim(), lang: lang});
            buffer = "";
        }
    }
    // ƒê·∫©y ph·∫ßn c√≤n d∆∞
    if (buffer.trim()) results.push({text: buffer.trim(), lang: lang});
    
    return results;
}

function parseMixedText(text) {
    if (!text) return [];

    // B∆∞·ªõc 1: T√°ch s∆° b·ªô Nga/Vi·ªát (nh∆∞ c≈©)
    const rawParts = [];
    let currentBuffer = "";
    let currentLang = null;

    for (let char of text) {
        const code = char.charCodeAt(0);
        const isRussian = (code >= 1024 && code <= 1279) || code === 1025 || code === 1105; 
        const charLang = isRussian ? 'ru-RU' : 'vi-VN';
        const isNeutral = /[0-9\s.,!?;:()"'`\-]/.test(char);

        if (isNeutral) {
            currentBuffer += char;
            continue;
        }

        if (currentLang === null) currentLang = charLang;

        if (charLang !== currentLang) {
            if (currentBuffer.trim().length > 0) {
                rawParts.push({ text: currentBuffer, lang: currentLang });
            }
            currentBuffer = char;
            currentLang = charLang;
        } else {
            currentBuffer += char;
        }
    }
    if (currentBuffer.trim().length > 0) {
        rawParts.push({ text: currentBuffer, lang: currentLang || 'vi-VN' });
    }

    // B∆∞·ªõc 2: BƒÉm nh·ªè c√°c ph·∫ßn Nga/Vi·ªát th√†nh c√°c c√¢u ng·∫Øn (Smart Split)
    // ƒê√¢y l√† b∆∞·ªõc FIX l·ªói th·∫ª d√†i
    const finalSegments = [];
    for (let part of rawParts) {
        const subSegments = splitSmart(part.text, part.lang);
        finalSegments.push(...subSegments);
    }
    
    return finalSegments;
}

function splitLongText(text, lang) {
    const MAX_LENGTH = 150; // Gi·ªõi h·∫°n k√Ω t·ª± m·ªói l·∫ßn ƒë·ªçc (Google TTS th√≠ch < 200)
    
    // N·∫øu ng·∫Øn th√¨ tr·∫£ v·ªÅ lu√¥n
    if (text.length <= MAX_LENGTH) return [{text: text, lang: lang}];

    const results = [];
    let remaining = text;

    while (remaining.length > 0) {
        if (remaining.length <= MAX_LENGTH) {
            results.push({text: remaining, lang: lang});
            break;
        }

        // T√¨m ƒëi·ªÉm c·∫Øt h·ª£p l√Ω (d·∫•u ch·∫•m, ph·∫©y) g·∫ßn m·ªëc 150 nh·∫•t
        // T√¨m d·∫•u ch·∫•m c√¢u trong kho·∫£ng t·ª´ k√Ω t·ª± 50 ƒë·∫øn 150
        let splitIndex = -1;
        const punctuation = ['.', ';', '?', '!', ',', ')'];
        
        // C·ªë g·∫Øng t√¨m d·∫•u c√¢u ·ªü cu·ªëi ƒëo·∫°n cho ph√©p
        for (let i = MAX_LENGTH; i > 50; i--) {
            if (punctuation.includes(remaining[i])) {
                splitIndex = i + 1; // C·∫Øt sau d·∫•u c√¢u
                break;
            }
        }

        // N·∫øu kh√¥ng t√¨m th·∫•y d·∫•u c√¢u, ƒë√†nh c·∫Øt t·∫°i kho·∫£ng tr·∫Øng
        if (splitIndex === -1) {
            splitIndex = remaining.lastIndexOf(' ', MAX_LENGTH);
        }

        // N·∫øu v·∫´n kh√¥ng t√¨m th·∫•y (t·ª´ qu√° d√†i), c·∫Øt c·ª©ng t·∫°i MAX_LENGTH
        if (splitIndex === -1) splitIndex = MAX_LENGTH;

        // C·∫Øt v√† ƒë·∫©y v√†o m·∫£ng
        const chunk = remaining.substring(0, splitIndex).trim();
        if (chunk) results.push({text: chunk, lang: lang});
        
        remaining = remaining.substring(splitIndex).trim();
    }

    return results;
}

    function hideButton() {
        const btn = document.getElementById('selectionSpeakBtn');
        if (btn) btn.style.display = 'none';
    }
// H√†m ti·ªán √≠ch: Tr√≠ch xu·∫•t Lemma v√† Stem t·ª´ m·ªôt th·∫ª Word Card
// H√†m ti·ªán √≠ch: Tr√≠ch xu·∫•t d·ªØ li·ªáu s·∫°ch ƒë·ªÉ ƒë·ªçc
function getDataFromCard(card) {
    // 1. L·∫•y Lemma (T·ª´ v·ª±ng)
    const lemmaEl = card.querySelector('.lemma');
    // L·∫•y text, x√≥a icon loa v√† s·ªë 
    const lemma = lemmaEl ? lemmaEl.innerText.replace(/[üîä0-9]/g, '').trim() : "";
    
    // M·∫∑c ƒë·ªãnh Stem = Lemma
    let stem = lemma; 

    // 2. L·∫•y n·ªôi dung nghƒ©a (Meaning)
    const meaningEl = card.querySelector('.meaning-wrapper');
    let meaningText = "";

    if (meaningEl) {
        // A. T√¨m Stem trong nghƒ©a (Logic c≈©)
        const rawContent = meaningEl.innerText;
        const stemMatch = rawContent.match(/\(([–∞-—è–ê-–Ø—ë–Å]+)\|[–∞-—è–ê-–Ø—ë–Å]*\)/);
        if (stemMatch && stemMatch[1]) {
            stem = stemMatch[1];
        }

        // B. L·∫•y n·ªôi dung ƒë·ªÉ ƒë·ªçc
        // Clone ri√™ng ph·∫ßn nghƒ©a ƒë·ªÉ x·ª≠ l√Ω
        const meaningClone = meaningEl.cloneNode(true);
        
        // X√≥a c√°c ph·∫ßn kh√¥ng n√™n ƒë·ªçc trong nghƒ©a (n·∫øu c√≥ n√∫t th·ª´a)
        // V√≠ d·ª•: X√≥a d√≤ng "Ch∆∞a c√≥ nghƒ©a..." n·∫øu b·∫°n kh√¥ng mu·ªën nghe n√≥
        // const noDataMsg = meaningClone.querySelector('.text-muted');
        // if (noDataMsg && noDataMsg.innerText.includes('Ch∆∞a c√≥ d·ªØ li·ªáu')) meaningClone.remove();

        meaningText = meaningClone.innerText;
    }
    
    // 3. Gh√©p th√†nh vƒÉn b·∫£n ho√†n ch·ªânh ƒë·ªÉ ƒë·ªçc
    // N·∫øu nghƒ©a tr·ªëng ho·∫∑c l√† "Ch∆∞a c√≥ d·ªØ li·ªáu...", ch·ªâ ƒë·ªçc t·ª´ v·ª±ng th√¥i
    let fullTextToRead = lemma;
    if (meaningText && !meaningText.includes("Ch∆∞a c√≥ d·ªØ li·ªáu")) {
        fullTextToRead = lemma + ". " + meaningText; 
    }

    return { 
        lemma: lemma, 
        stem: stem,
        fullText: fullTextToRead 
    };
}

//     // --- S·ª∞ KI·ªÜN B√îI ƒêEN (ƒê√É C·∫¨P NH·∫¨T T√åM G·ªêC T·ª™ | ) ---
document.addEventListener('mouseup', function(e) {
    setTimeout(() => {
        const selection = window.getSelection();
        const text = selection.toString().trim();
        
        // Lu√¥n t√¨m n√∫t hi·ªán t·∫°i (ƒë·ªÉ tr√°nh l·ªói null)
        const currentBtn = document.getElementById('selectionSpeakBtn');
        if (!currentBtn) return;

        if (text.length > 0) {
            const range = selection.getRangeAt(0);
            
            // --- [LOGIC M·ªöI] T√åM G·ªêC T·ª™ (ROOT/STEM) ---
            let rootWord = "";
            
            // 1. T√¨m th·∫ª cha ch·ª©a ƒëo·∫°n b√¥i ƒëen
            let container = range.commonAncestorContainer;
            if (container.nodeType === 3) container = container.parentNode; 
            const parentCard = container.closest('.word-card');
            if (parentCard) {
                // S·ª¨ D·ª§NG H√ÄM TI·ªÜN √çCH M·ªöI
                const data = getDataFromCard(parentCard);
                
                // G√°n s·ª± ki·ªán click
                const handleSpeakClick = function(event) {
                    event.preventDefault(); event.stopPropagation();
                    
                    // Truy·ªÅn c·∫£ lemma v√† stem v√†o
                    speak(text, data.lemma, data.stem); 
                };
            }
            // // ---------------------------------------------

            const rect = range.getBoundingClientRect();
            
            // Clone n√∫t ƒë·ªÉ x√≥a s·ª± ki·ªán c≈©
            const newBtn = currentBtn.cloneNode(true);
            currentBtn.parentNode.replaceChild(newBtn, currentBtn);
            
            newBtn.innerHTML = `üîä ƒê·ªçc ƒëo·∫°n n√†y`;
            
            // T√≠nh to√°n v·ªã tr√≠ hi·ªÉn th·ªã
            const topPos = rect.top - 45;
            const leftPos = rect.left + (rect.width / 2) - (newBtn.offsetWidth / 2);
            
            newBtn.style.left = leftPos + 'px';
            if (topPos > 0) {
                newBtn.style.top = topPos + 'px';
            } else {
                newBtn.style.top = (rect.bottom + 10) + 'px';
            }
            
            newBtn.style.display = 'block';

            // G√°n s·ª± ki·ªán click v·ªõi g·ªëc t·ª´ (rootWord) chu·∫©n x√°c v·ª´a t√¨m ƒë∆∞·ª£c
            const handleSpeakClick = function(event) {
                event.preventDefault(); 
                event.stopPropagation();
                
                // G·ªçi h√†m speak v·ªõi rootWord ƒë√£ x·ª≠ l√Ω
                speak(text, rootWord); 
            };

            newBtn.addEventListener('click', handleSpeakClick);
            newBtn.addEventListener('touchstart', handleSpeakClick, {passive: false});

        } else {
            if (e.target.id !== 'selectionSpeakBtn') {
                const btn = document.getElementById('selectionSpeakBtn');
                if(btn) btn.style.display = 'none';
            }
        }
    }, 10);
});

    // ·∫®n n√∫t khi nh·∫•n chu·ªôt xu·ªëng b·∫•t k·ª≥ ch·ªó n√†o kh√°c
    document.addEventListener('mousedown', function(e) {
        if (e.target.id !== 'selectionSpeakBtn') {
            hideButton();
        }
    });

    // ·∫®n khi cu·ªôn trang
    window.addEventListener('scroll', hideButton);

    init();
</script>

</body>

</html>
